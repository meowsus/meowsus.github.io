---
layout: post
title: Sunday
subtitle: it's 2025 and still forms are hard
---

This is going to be a long post and I don't want it to be.

I have spent the last week thinking about forms in Next.js. It's been a living nightmare. Every time I close my eyes they snap back open again and I think about server actions, client-side validation, error handling. Ugh. It won't stop.

Let's start at the beginning...

## Next.js hates the client

That's what I've come to understand, based on [their documentation](https://nextjs.org/docs/pages/guides/forms). In here you read things like

> For client-side validation, you can use the HTML attributes like `required` and `type="email"` for basic validation.

Cool. _Those_ totally catch _everything_ you need on the client... But whatever. I set forth accepting that I should start off with HTML form validation. We can just handle validation errors from the server with `useActionState`:

> To display validation errors or messages, turn the component that defines the `<form>` into a Client Component and use React `useActionState`.

This _is_ a server component:

```tsx
export default function Whatever() {
  async function createFoo(formData: FormData) {
    "use server";

    // do
    // the
    // things
  }

  return <form action={createFoo}>...</form>;
}
```

But the documentation tells us to make the component a client component in order to render validation messages. Something like:

```tsx
"use client";

import { useActionState } from "react";

export default function Whatever() {
  async function createFoo(formData: FormData) {
    "use server";

    // do
    // the
    // things
  }

  const [state, formAction, pending] = useActionState(createFoo, {});

  <form action={formAction}>...</form>;
}
```

Okay, but now our forms don't work with JavaScript disabled. I mean, sure, it's not realistic to pander to the 0.2% of crackpots worldwide who manually disable JavaScript but [that's not the whole story](https://www.reddit.com/r/webdev/comments/48z7jz/comment/d0nxftd/).

Call me old fashioned, but if I'm building a full-stack web application I'd like my forms to work out-of-the-box without the client being involved _first_, even if the experience isn't all that great, and then progressively enhance that experience with JavaScript. It's just the way I was raised.

Ok, so how might I do this? Let's walk back the implementation of a real example from [the cookbook project](https://github.com/meowsus/cookbook) I'm working on:

```tsx
import { z } from "zod";
import { auth } from "@/lib/auth";
import { redirect } from "next/navigation";
import { createSource } from "@/lib/db/sources";

const CreateSourceSchema = z.object({
  url: z.url().nonempty(),
});

export default function CreateSourceForm() {
  function createSourceAction(formData: FormData) {
    const parsedFormData = CreateSourceSchema.safeParse({
      url: formData.get("url"),
    });

    if (parsedFormData.success) {
      return {
        error: z.prettifyError(parsedFormData.error),
        fields: Object.fromEntries(formData.entries()),
      };
    }

    const { url } = parsedFormData.data;

    await createSource({
      url,
      user: {
        connect: { id: session.user.id },
      },
    });

    redirect("/sources");
  }

  return (
    <form action={createSourceAction} className="space-y-2">
      <div className="flex gap-2">
        <Input
          name="url"
          type="url"
          placeholder="https://example.com"
          required
        />

        <Button type="submit">Add</Button>
      </div>
    </form>
  );
}
```

Okay. This _should_ work, but will provide the user with zero feedback any of those guards get triggered or we run into an issue while saving the record to the database. Why? _Even PHP_ can respond back to the same page and supply server-rendered error messages:

```php
<?php
// Initialize variables
$url = '';
$errors = [];
$success = false;

// Check if form was submitted
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Get form data
    $url = trim($_POST['url'] ?? '');

    // Validate URL
    if (empty($url)) {
        $errors['url'] = 'URL is required';
    } elseif (!filter_var($url, FILTER_VALIDATE_URL)) {
        $errors['url'] = 'Please enter a valid URL';
    }

    // If no errors, process the form
    if (empty($errors)) {
        // Here you would typically save to database or process the URL
        // For this example, we'll just show a success message
        $success = true;

        // Clear form data on success
        $url = '';
    }
}
?>

<!DOCTYPE html>
<html lang="en">
<body>
    <h1>URL Form</h1>

    <?php if ($success): ?>
        <p><strong>Success!</strong> URL has been processed successfully.</p>
    <?php endif; ?>

    <form method="POST" action="">
        <label for="url">URL:</label>
        <input
            type="url"
            id="url"
            name="url"
            value="<?php echo htmlspecialchars($url); ?>"
        >
        <?php if (isset($errors['url'])): ?>
            <span style="color: red;"><?php echo htmlspecialchars($errors['url']); ?></span>
        <?php endif; ?>
        <br><br>
        <button type="submit">Submit</button>
    </form>
</body>
</html>
```

Like, get it together, fellas... anyway...

## Next.js loves the client

So my aforementioned opinion has pulled a one-eighty. Next.js loves the client. And that makes sense. I'm essentially saying, "Hey, Next, do you remember a decade-plus ago, when React came out, and the majority of the internet tripped and fell in a JavaScript hole? Yeah. Me neither."

Next is React. Sure, you can now write React on the backend and it's compiled to HTML, but you better believe that they are going to smash their escape hatch button at the first sign of trouble. We're not writing Single Page Applications backed solely by an API any longer, but we also don't seem to be at a place of maturity with titans like, oh, [INSERT THE NAME OF ANY OTHER WEB FRAMEWORK HERE].

`/me dismounts soap box`

> React extends the HTML `<form>` element to allow Server Function to be invoked with the HTML `action` prop.

Okay, so I take this to mean that my real example, above, which tries to create a source from a given URL, should work with JavaScript disabled. The action handles _all the things_ from ensuring the user is authenticated, to making sure the URL is real (fun fact: did you know that `foo:` is technically a valid URL?), to creating the source, to redirecting. Everything a server action should do.

And TypeScript hates it:

```
Type '(formData: FormData) => Promise<{ error: string; fields: { [k: string]: FormDataEntryValue; }; }>' is not assignable to type 'string | ((formData: FormData) => void | Promise<void>) | undefined'.
  Type '(formData: FormData) => Promise<{ error: string; fields: { [k: string]: FormDataEntryValue; }; }>' is not assignable to type '(formData: FormData) => void | Promise<void>'.
    Type 'Promise<{ error: string; fields: { [k: string]: FormDataEntryValue; }; }>' is not assignable to type 'void | Promise<void>'.
      Type 'Promise<{ error: string; fields: { [k: string]: FormDataEntryValue; }; }>' is not assignable to type 'Promise<void>'.
        Type '{ error: string; fields: { [k: string]: FormDataEntryValue; }; }' is not assignable to type 'void'.ts(2322)
```

This TypeScript error is actually confirming everything: server actions, when passed directly to a form's `action` prop, must return `void`. Ok. Whatever. I guess our only option is to throw errors?

```tsx
async function createSourceAction(formData: FormData) {
  "use server";

  const session = await auth();

  if (!session?.user?.id) {
    throw new Error("You must be logged in to create a source");
  }

  const parsedFormData = CreateSourceFormDataSchema.safeParse({
    url: formData.get("url"),
  });

  if (!parsedFormData.success) {
    throw new Error(z.prettifyError(parsedFormData.error));
  }

  const { url } = parsedFormData.data;

  await createSource({
    url,
    user: {
      connect: { id: session.user.id },
    },
  });

  redirect("/sources");
}
```

This appeases the great `tsc`. And it works with and without JavaScript.

But wait... didn't I read something somewhere? [Oh yeah](https://nextjs.org/docs/app/getting-started/error-handling#server-functions).

> For these errors, avoid using `try`/`catch` blocks and throw errors. Instead, model expected errors as return values.

So all roads lead back to `useActionState`. My brain says it should. I mean, client components are still initially rendered by the server. We can get back to something closer to our initial example:

```tsx
"use client";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { auth } from "@/lib/auth";
import { createSource } from "@/lib/db/sources";
import { redirect } from "next/navigation";
import { useActionState } from "react";
import { z } from "zod";

const CreateSourceFormDataSchema = z.object({
  url: z.url(),
});

export default function CreateSourceForm() {
  async function createSourceAction(prevState: unknown, formData: FormData) {
    "use server";

    const session = await auth();

    if (!session?.user?.id) {
      return {
        error: "You must be logged in to create a source",
        fields: Object.fromEntries(formData.entries()),
      };
    }

    const parsedFormData = CreateSourceFormDataSchema.safeParse({
      url: formData.get("url"),
    });

    if (!parsedFormData.success) {
      return {
        error: z.prettifyError(parsedFormData.error),
        fields: Object.fromEntries(formData.entries()),
      };
    }

    const { url } = parsedFormData.data;

    await createSource({
      url,
      user: {
        connect: { id: session.user.id },
      },
    });

    redirect("/sources");
  }

  const [state, formAction, pending] = useActionState(createSourceAction, null);

  return (
    <form action={formAction} className="space-y-2">
      <div className="flex gap-2">
        <Input
          name="url"
          type="url"
          placeholder="https://example.com"
          required
        />

        <Button type="submit" disabled={pending}>
          Add
        </Button>
      </div>

      {state?.error && <p className="text-red-500">{state.error}</p>}
    </form>
  );
}
```

But, we can't. For some godless and evil reason, despite the documentation eluding to you being able to `"use server"` inside a client component, you can't. You have to move your server action outside of the file and mark it with `"use server"`. Okay. Whatever.

```tsx
"use client";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { createSourceAction } from "@/lib/actions/sources";
import { useActionState } from "react";

export default function CreateSourceForm() {
  const [state, formAction, pending] = useActionState(createSourceAction, null);

  return (
    <form action={formAction} className="space-y-2">
      <div className="flex gap-2">
        <Input
          name="url"
          type="url"
          placeholder="https://example.com"
          defaultValue={state?.fields?.url as string}
          required
        />

        <Button type="submit" disabled={pending}>
          Add
        </Button>
      </div>

      {state?.error && <p className="text-red-500">{state.error}</p>}
    </form>
  );
}
```

Okay. Okay. This form works without JavaScript enabled. If I change the input's `type` to `text` and input anything other than a valid URL we see an error message after a full-page refresh.

Sorry I doubted you, Next. I'm sorry that I implied that PHP is better than you. I swear I tried this before... I've tried everything this week.

Lesson learned: I'll never trust myself again.

## A couple more things

Now that I've proven myself to be an idiot, and I've hopefully proven the same to you, I'll briefly explain how I got to [this monstrosity](https://github.com/meowsus/cookbook/pull/33).

First, submitting a URL already attached to a Source will throw a `Prisma.PrismaClientKnownRequestError`. Without a `try`/`catch` block in place, we won't be able to recover from the error. It triggers the error boundary. Unideal. I'd rather display the server error like I would any other error.

This led me to [next-safe-action](https://next-safe-action.dev/) which touts the ability to just run the damn action with impunity and catch all manner of errors in buckets like `validationError` and `serverError`. This felt good. I was able to abstract away the authentication bit into the safe action client, like so:

```ts
import {
  createSafeActionClient,
  DEFAULT_SERVER_ERROR_MESSAGE,
} from "next-safe-action";
import { auth } from "./auth";
import { z } from "zod";
import { Prisma } from "../../generated/prisma";

class ActionError extends Error {}

export const actionClient = createSafeActionClient({
  defineMetadataSchema() {
    return z.object({
      actionName: z.string(),
    });
  },
  handleServerError: (error) => {
    console.error(error);

    if (error instanceof ActionError) {
      return { error: error.message };
    }

    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      return { error: error.message };
    }

    return { error: DEFAULT_SERVER_ERROR_MESSAGE };
  },
});

export const authActionClient = actionClient.use(async ({ next }) => {
  const session = await auth();

  if (!session?.user?.id) {
    throw new Error("Unauthorized");
  }

  return await next({
    ctx: {
      userId: session.user.id,
    },
  });
});
```

And build my action thusly:

```ts
export const createSourceAction = authActionClient
  .metadata({ actionName: "createSourceAction" })
  .inputSchema(CreateSourceSchema)
  .action(async ({ parsedInput: { url }, ctx }) => {
    const source = await createSource({
      url,
      user: {
        connect: { id: ctx.userId },
      },
    });

    redirect(`/sources/${source.id}`);
  });
```

Much cleaner. Now I can use `authActionClient` to ensure the user is present in the session and grab it out of context, as needed. I also don't need to check that the fields are valid, since `next-safe-action` handles that with the `inputSchema()` instance method.

But I am losing something here... `fields`. For the life of me I couldn't figure out how to return the submitted form state back to the browser if something went awry. I chalk this up to [their form action documentation being dogshit](https://next-safe-action.dev/docs/recipes/form-actions). Zero real-world examples here. Like, where can I collect the form data submitted by the user without collecting it myself? And how would I return that previously submitted form data back to the browser if the source creation step failed without using a `try`/`catch` block?

That experiment failed so hard that I wound up just red-pilling myself into using [React Hook Form](https://react-hook-form.com/) alongside the [`next-safe-action/adapter-react-hook-form`](https://github.com/next-safe-action/adapter-react-hook-form). It works. It's pretty chubby. I'm not happy with it. I wanted to keep things simple.

Another reason why I caved and used React Hook Form was because [ShadCN](https://ui.shadcn.com/), the component library I wanted to work with, forces an RHF dependency with their `Form` component. More dogshit.

I should really take another run at this. I should use [daisyUI](https://daisyui.com/) or something more agnostic for the components. I should really dig deeper into `next-safe-action` to figure out how to always return the submitted, unparsed form data from the server back to the client. Essentially, I should be able to use the form's `action` prop as intended without having to jump through a million hoops and should never be forced to use `onSubmit`. Truly I could get by with HTML form validation if I could consistently return the previous values from a form submission back to the client if we encounter an error state.

This has been my cycle this week: I want this, it doesn't seem like I can have this, I give up, oh wait, what about this, let me try that, that doesn't work either, I give up, oh wait...

It really shouldn't be this hard.
